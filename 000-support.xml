<!--
    L'espace de nom donne un contexte à un terme, par exemple certains mots ont plusieurs définitions, 
    c'est le contexte dans lequel on utilise ce mot qui donne sa "fonction / définition" finale

    On peut par exemple associer le document à l’espace de nom XHTML et par soucis de praticité 
    on va utiliser le préfixe html (faciliter la lecture humaine du document) 
    car il faut savoir qu’à la base le choix du préfixe est totalement arbitraire.
-->
<html:html xmlns:html="http://www.w3.org/1999/xhtml">
    <html:head>
        <html:title>Les espaces de noms</html:title>
    </html:head>
    <html:body>
        ....
    </html:body>
</html:html>

<!--
    il est possible de déclarer plusieurs espaces de nom pour un même document
-->
<html:html 
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:mml="http://www.w3.org/1998/Math/MathML"
    >
    <html:head>
        <html:title>Les espaces de noms</html:title>
    </html:head>
    <html:body>
        ....
        <mml:math>
            <mml:apply>
                <mml:eq>
                    ...
                </mml:eq>
            </mml:apply>
        </mml:math>
    </html:body>
</html:html>

<!-- 
    on peut limiter la portée de la déclaration d'un espace de nom,
    pour la déclaration multiple, il est aussi possible de n'utiliser (d'appeler) une espace de nom 
    seulement quand il est requis
-->
<!-- Ici on utlise le dialecte html -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        ....
        <!-- à partir de cette balise, on utilise le dialect math et plus le dialecte html -->
        <math xmlns="http://www.w3.org/1998/Math/MathML"> 
            <apply>
                <eq>
                    ...
                </eq>
            </apply>
        </math>
        <!-- on est "sorti" de la portée du dialecte math, on reviens dansle dialecte html -->
    </body>
</html>

<!--
    Mais comment faisons nous s'il n'existe pas de contexte pour nos données, ou seulement une partie ?
    Il est possible "d'annuler" un espace de nom (de la même façon que l'on a appelé un espace de nom de manière ponctuelle)
-->

<!-- Ici on utlise le dialecte html -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        ....
        <!-- 
            En déclarant xmlns à 'vide' pour la balise name, elle-même et les balises qu'elle contient ne se réfèreront plus au
            vocabulaire xhtml
        -->
        <name xmlns=""> 
            <firstName>Gaston</firstName>
            <lastName>Lagaffe</lastName>
        </name>
        <!-- à la sortie de la balise name, on revient dans le dialect xhtml -->
    </body>
</html>

<!-- 
XML
    http://www.w3.org/XML/1998/namespace 
XInclude
    http://www.w3.org/2001/XInclude 
XLink
    http://www.w3.org/1999/xlink 
MathML
    http://www.w3.org/1998/Math/MathML 
XHTML
    http://www.w3.org/1999/xhtml 
SVG
    http://www.w3.org/2000/svg 
Schémas
    http://www.w3.org/2001/XMLSchema 
Instances de schémas
    http://www.w3.org/2001/XMLSchema-instance 
Schematron
    http://purl.oclc.org/dsdl/schematron 
XSLT
    http://www.w3.org/1999/XSL/Transform 
XSL-FO
    http://www.w3.org/1999/XSL/Format 
DocBook
    https://tdg.docbook.org/tdg/5.1/ 
Dublin Core
    https://www.dublincore.org/specifications/dublin-core/dcmi-terms/ 


-->

<!-- DTD -->


<!ELEMENT balise (contenu)>

<!-- Balise contenant une autre balise -->
<contact>
    <nom>Durant</nom>
</contact>
<!-- pour la balise contact -->
<!ELEMENT contact (nom)>
<!-- pour la balise nom -->
<!ELEMENT nom (#PCDATA)>
<!-- Si la balise nom est vide -->
<!ELEMENT nom EMPTY>
<!-- une balise vide avec un attribut -->
<!-- Les attributs -->
<!ELEMENT balise (contenu)>
    <!ATTLIST balise attr>

<console src="test" />
<!ELEMENT console EMPTY>
    <!ATTLIST console src CDATA>

<!-- si la balise peut ou non avoir des données -->
<!ELEMENT nom ANY>
<!-- si la balise peut contenir plusieurs itérations d'une même balise -->
<!ELEMENT rolodex (contact+)>

<!-- avec le xml suivant -->
<rolodex>
    <contact>
        <nom>Durand</nom>
        <prenom>Jean</prenom>
        <age>42</age>
    </contact>
    <contact>
        <nom>ACME Inc</nom>
        <prenom></prenom>
        <age></age>
    </contact>
</rolodex>

<!ELEMENT rolodex (contact+)>
    <!ELEMENT contact (nom, prenom, age)>
        <!ELEMENT nom (#PCDATA)>
        <!ELEMENT prenom (#PCDATA)>
        <!ELEMENT age (#PCDATA)>
<!-- on peut avoir plusieurs contenus possible dans une balise -->

<!ELEMENT rolodex (contact+)>
    <!ELEMENT contact (nom | prenom, age)>
    <!-- ici, contact doit contenir soit un nom ou soit un prenom et age -->
    <!ELEMENT nom (#PCDATA)>
    <!ELEMENT prenom (#PCDATA)>
    <!ELEMENT age (#PCDATA)>
    
<!-- balise optionnelles : qu'elle apparaissent ou non -->
<!ELEMENT contact (nom, prenom?, adresses, emails)>
<!-- ici, la balise prénom peut ne pas apparaître -->

<!-- balise optionnelles répétées -->
<!ELEMENT adresses (adresse*)>
<!-- ici, la balise adresses peut contenir de 0 à X adresse -->

<!-- balise obligatoires répétées -->
<!ELEMENT rolodex (contact+)>
<!-- ici, rolodex doit contenir au moins une balise contact et peut en contenir plus -->

<!-- Les attributs -->
<!ELEMENT balise (contenu)>
    <!ATTLIST balise attr >

<!-- identifiant unique -->
<contact numero="n-1"></contact>
<!ELEMENT contact ANY>
    <!ATTLIST contact numero ID #REQUIRED>
<!-- la balise contact possède un attribut numéro qui est une attribut ID qui est unique et obligatoire -->

<!-- 
    Propriété de présence des attributs
    forme               signification
    #IMPLIED            Attribut facultatif
    #REQUIRED           Attribut obligatoire
    #FIXED valeur       Attribut avec cette valeur, non modifiable
    "valeur"            Attribut avec cette valeur par défaut et modifiable
-->

<!-- Attribut ayant pour référence (qui fait référence à) un attribut a valeur unique -->
<!ELEMENT contact ANY>
    <!ATTLIST contact numero ID #REQUIRED>
<!ELEMENT adresse ANY>
    <!ATTLIST adresse userAdresse IDREF #REQUIRED>
    <!ATTLIST adresse personne (physique | morale) "physique">
<rolodex>
    <contacts>
        <contact personne="physique" numero="n-1">
            ....
        </contact>
        <contact personne="morale" numero="n-2">
            ....
        </contact>
    </contacts>
    <adresses>
        <adresse type="facturation" userAdresse="n-1">
            ....
        </adresse>
        <adresse type="livraison" userAdresse="n-1">
            ....
        </adresse>
        <adresse type="facturation" userAdresse="n-2">
            ....
        </adresse>
    </adresses>
</rolodex>

<!-- autre exemple -->
<artist name="Nick Cave" artistID="NC"/>
<album name="Murder Ballads" albumArtistID="NC"/>
<album name="The boatman's call" albumArtistID="NC"/>

<!ELEMENT artist EMPTY>
<!ATTLIST artist name CDATA #REQUIRED>
<!ATTLIST artist artistID ID #REQUIRED>

<!ELEMENT album EMPTY>
<!ATTLIST album name CDATA #REQUIRED>
<!ATTLIST album albumArtistID IDREF #IMPLIED>


<!-- exemple IDREFS (plusieurs élément référence le même élément -->
<artist name="Korn" artistID="K-0001" />
<artist name="Ice Cube" artistID="IC-0002" />
<artist name="Incubus" artistID="I-0003" />
<artist name="Limp Bizkit" artistID="LB-0004" />
<artist name="Orgy" artistID="O-0005" />
<album name="Follow the leader" albumArtistID="K-0001" />
<album name="Family values tour '98" albumArtistID="K-0001 IC-0002 I-0003 LB-0004 O-0005" />

<!ELEMENT artist EMPTY>
<!ATTLIST artist name CDATA #REQUIRED>
<!ATTLIST artist artistID ID #REQUIRED>

<!ELEMENT album EMPTY>
<!ATTLIST album name CDATA #REQUIRED>
<!ATTLIST album albumArtistID IDREFS #IMPLIED>

<!-- attribut avec une valeur par dfaut -->
<!ATTLIST adresse personne (physique | morale) "physique">
<!-- valide -->
<contact personne="physique"></contact>

<!-- valide -->
<contact personne="morale"></contact>

<!-- invalide -->
<contact personne="toto"></contact>

<!-- valide mais sera considéré par défaut comme physique -->
<contact personne=""></contact>

<!-- 
    les constantes : si l'attribut est présent dans la balise, il doit avoir une valeur définie. 
    Mais s'il n'est pas présent, cette valeur sera celle utilisée par défaut
-->
<!ATTLIST prix devise CDATA "euro">
<!-- valide la devise sera euro et rien d'autre -->
<prix devise="euro">12</prix>
<!-- valide la devise sera euro et rien d'autre -->
<prix>12</prix>

<!-- invalide : la devise doit être en euro -->
<prix devise="USD">12</prix>

<!-- 
    Les entités 
    se sont des alias qui permettent de réutiliser des informations dans le document xml ou dans les DTD
        - générales
        - paramètres
        - externes
-->

<!-- 
    entité générale
    associe un alias à une information dans le document
-->

<!ENTITY dacia "Dacia">
<!ENTITY renault "Renault">
<!ENTITY citroen "Citroën">

<voiture>
    <marque>&dacia;</marque>
</voiture>
<voiture>
    <marque>&renault;</marque>
</voiture>
<voiture>
    <marque>&citroen;</marque>
</voiture>

<!-- 
    le xml est à lire comme suit
-->

<voiture>
    <marque>Dacia</marque>
</voiture>
<voiture>
    <marque>Renault</marque>
</voiture>
<voiture>
    <marque>Citroën</marque>
</voiture>

<!-- 
    entité paramètre
    N'apparaît que dans les DTD
    Elle associent un alias à une partie de la déclaration dans les DTD
-->

<voiture marque="Dacia" />
<voiture marque="Renault" />
<voiture marque="Citroën" />
<!-- DTD classique pour l'attribut marque -->
<!ATTLIST voiture marque (Dacia|Renault|Citroën) #REQUIRED>

<!-- avec l'entité paramètre -->
<!ENTITY % listeMarques "marque (Dacia|Renault|Citroën) #REQUIRED">
<!ATTLIST voiture %listeMarques>

<!-- autre exemple -->
<!ENTITY % type "nom?, prenom?">
<!ELEMENT contact (%type, surnom?)>
<!ELEMENT personnage (%type, role)>

<!-- traduit en DTD classique -->
<!ELEMENT contact (nom?, prenom?, surnom?)>
<!ELEME?T personnage (nom?, prenom?, role)>

<!-- 
    Entité externe 
    Permetttent de faire référence, comme les entités générales, à des informations a utiliser dans le document 
    xml, mais elle sont écrites et déclarées dans un fichier externe
-->

<!ENTITY dacia SYSTEM "dacia.xml">
<!ENTITY renault SYSTEM "renault.xml">
<!ENTITY citroen SYSTEM "citroen.xml">
<voiture>
    &dacia;
</voiture>
<voiture>
    &renault;
</voiture>
<voiture>
    &citroen;
</voiture>


<!-- dacia.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE description [
    <!ELEMENT description (marque, modele, portes)>
    <!ELEMENT marque (#PCDATA)>
    <!ELEMENT modele (#PCDATA)>
    <!ELEMENT portes (#PCDATA)>
]>
<description>
    <marque>
        Dacia
    </marque>
    <modele>
        Sandero
    </modele>
    <portes>
        5
    </portes>
</description>

<!-- 
    Autre schéma de validation XML : XSD (Xml Schema Definition)
    Pourquoi ? 
    les DTD ne sont pas au format XML, c'est un nouveau langage avec sa propre syntaxe et ses règles.
    => il faut l'utiliser avec xml et il se peut que certaines API liront le XML et les DTD de façons différentes?
    Enfin, on ne peut pas typer les données, on indique juste qu'une balise contient ou non des données 
    mais impossible de préciser si c'est une chaîne de caractère, un nombre, etc.
    
    Le xsd permet de typer les données, il est plus précis sur l'écriture des contraintes, il s'écrit en xml, 
    se stocke dans un fichier externe ayant l'extension .xsd, il utilise comme les fichiers xml un prologue 
    dont le nom de l'élément racine nous est imposé
-->

<!-- prologue d'un fichier .xsd -->
<?xml version="1.0" encoding="UTF-8"?>
<!-- élément racine -->
<xsd:schema xmlns="http://www.w3.org/2001/XMLSchema">
</xsd:schema>

<!-- on déclare un espace de nom avec xmlns:xsd, de fait, tous les éléments du xsd seront préfixés par xsd: -->

<!-- 
    il faut ensuite rattacher ce fichier de schéma au xml concerné par le xsd
    il faut déclarer l'attachement du fichier dans la balise racine du xml
    mais pour appeler ce fichier il faut utiliser le vocabulaire schema-instance
-->

<!-- xsd ne décrivant pas d'espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="agenda.xsd">
    <!-- schemaLocation déclare un xsd ne décrivant pas un espace de nom -->
    <rolodex>
        <nom>
            Durant
        </nom>
    </rolodex>
    <garage>
        <voiture>
            <marque>
                Opel
            </marque>
        </voiture>
    </garage>
</agenda>

<!-- xsd déclarant un espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:Contact contact.xsd" xsi:schemaLocation="urn:Garage garage.xsd">
    <!-- schemaLocation déclare un xsd décrivant un espace de nom -->
    <Contact:contact xmlns:Contact="urn:Contact">
        <Contact:nom>
            Durant
        </Contact:nom>
    </Contact:contact>
    <Garage:garage xmlns:Garage="urn:Garage">
        <Garage:voiture>
            <Garage:marque>
                Opel
            </Garage:marque>
        </Garage:voiture>
    </Garage:garage>
</agenda>

<!-- 
    Déclaration des éléments
    Deux type d'éléments : simples et complexes

    Élément simple : 
    une balise, sans attribut, ne contenant pas d'autre balise, dont le type de donnée contenu est simple
    
    Élément comlexe : 
    une balise qui contient d'autre balise, ou que le type de donnée est complexe, ou qu'elle contient au moins un attribut.
-->

<!-- ni atribut, ni élément et donnée simple => élément simple -->
<nom>Duflot</nom>

<!-- Contient un attribut : personne est un élément complexe -->
<!-- attribut type : contient une donnée simple => élément simple -->
<personne type="physique">Nicolas Duflot</personne>

<!-- Élement comple (contient d'autres balise -->
<personne>
    <!-- Élément complexe (contient un attribut) -->
    <nom type="usage">Duflot</nom>
    <nom type="jeune-fille">Duflot</nom>
    <!-- Élement simple (ni attribut ni balise) -->
    <prenom>Tiphaine</prenom>
</personne>

<!-- 
    déclarer  un élément simple
    mot clef : element (avec le namespace déterminé, pour l'exemple xsd)
-->

<nom>Duflot</nom>
<prenom>Nicolas</prenom>
<age>43</age>

<!-- en xsd -->
<xsd:element name="nom" type="xsd:string" />
<xsd:element name="prenom" type="xsd:string" />
<xsd:element name="age" type="xsd:int" />

<!-- valeurs par défaut -->
<xsd:element name="nom" type="xsd:string" default="Doe" />
<xsd:element name="prenom" type="xsd:string" default="John" />
<xsd:element name="age" type="xsd:int" />

<!-- exemple de xml valides avec ce schéma -->
<!-- ex n°1 -->
<nom>Duflot</nom>
<prenom>Nicolas</prenom>
<age>43</age>

<!-- ex n°1 -->
<nom></nom>         <!-- valeur par défaut "Doe"-->
<prenom>Nicolas</prenom>
<age>43</age>

<!-- ex n°2 -->
<nom>Duflot</nom>
<prenom></prenom>   <!-- valeur par défaut "John"-->
<age>43</age>

<!-- ex n°3 -->
<nom></nom>         <!-- valeur par défaut "Doe"-->
<prenom></prenom>   <!-- valeur par défaut "John"-->
<age>43</age>

<!-- ex n°4 -->
<nom></nom>         <!-- valeur par défaut "Doe"-->
<prenom></prenom>   <!-- valeur par défaut "John"-->
<age></age>         <!-- il n'y a pas de valeur par défaut, mais peut être vide car non obligatoire -->

<!-- 
    Valeurs constantes
    Constante : valeur inchangeable, imposée et non valide si la balise est vide
-->

<xsd:element name="status" type="xsd:string" fixed="Employé·e" />
<!-- valide -->
<status>Employé·e</status>
<!-- invalide car donnée <> Employé·e -->
<status>Junior</status>
<!-- invalide car donnée absente -->
<status></status>

<!-- 
    Les attributs

    Se sont par essence des éléments simples, et le mot clef pour les déclarer 
    n'est pas element mais attribute (ne pas oublier le namespace xsd)

    on déclare un attribut avec les attributs name et type
-->

<personne type="physique"></personne>

<!-- attribut personne -->
<xsd:attribute name="type" type="xsd:string" />
<!-- 
    la déclaration de cet attribut intervient évidement lors de la déclaration 
    de l'élément personne, qui lui est un élément complexe, on verra sa déclaration plus tard 
-->

<!-- valeurs par défaut, valeurs inchangeables (constante), valeurs obligatoires -->
<!-- par défaut -->
<xsd:attribute name="type" type="xsd:string" default="physique" />
<!-- constante -->
<xsd:attribute name="devise" type="xsd:string" fixed="euro" />
<!-- valide -->
<prix devise="euro">23.5</prix>
<!-- valide -->
<prix devise="">23.5</prix>

<!-- l'attribut type doit être obligatoirement renseigné dans la balise personne -->
<xsd:attribute name="type" type="xsd:string" use="required" />
<!-- valide -->
<personne type="physique"></personne>
<!-- invalide -->
<personne type=""></personne>
<!-- invalide -->
<personne></personne>

<!-- les types de valeurs pour les élément et les attributs -->
<!-- string -->
<xsd:element name="string" type="xsd:string" />
<string>Karamasov</string>
<string>Une phrase choc</string>
<!-- certains caractères spéciaux, tel &, doivent être écrits avec la notation HTML & => &amp; -->
<string>&amp;</string>

<!-- language -->
<xsd:element name="langue" type="xsd:language" />
<!-- 
    norme code langue 
    deux lettres de base ISO 639 (code de la langue)
    peut être suivi par deux lettres ISO 3166 (code du pays)
    XX      (seul le code langue)
    XX-YY   (code langue-code pays)
-->
<langue>fr-FR</langue>
<langue>fr-CA</langue>
<langue>en</langue>
<langue>en-US</langue>
<langue>en-GB</langue>
<langue>en-CA</langue>

<!--
    nmtoken string sans espace et seulement avec les caractère spéciaux acceptés .-_ et : 
    ne peut être utilisé que pour un attribut
-->
<xsd:attribute name="myToken" type="xsd:NMTOKEN" />
<balise myToken="A:B_B-2.3">Contenu de la balise</balise>

<!--
    nmtokens : liste de nttoken, séparés par un espace, mais seulement avec les caractère spéciaux acceptés .-_ et : 
    ne peut être utilisé que pour un attribut
-->
<xsd:attribute name="myTokens" type="xsd:NMTOKENS" />
<balise myTokens="A:B_B-2.3">Contenu de la balise</balise>
<balise myTokens="A:B_B-2.3 AZERTY 123456">Contenu de la balise</balise>

<!-- ID IDREF -->
<xsd:attribute name="num" type="ID" />
<xsd:attribute name="parent" type="IDREF" />
<personne num="P1">Paul</personne>
<personne num="P2">JP</personne>
<personne num="P3" parent="P1">Martin</personne>
<personne num="P4" parent="P2">Camille</personne>

<!-- ID IDREFS -->
<xsd:attribute name="num" type="ID" />
<xsd:attribute name="parents" type="IDREFS" />
<personne num="P0" parents="">Clotaire</personne>
<personne num="P1" parents="">JP</personne>
<personne num="P2" parents="">Marie</personne>
<personne num="P3" parents="P0">Astrid</personne>
<personne num="P4" parentss="P0">Paul</personne>
<personne num="P5" parents="P1 P3">Martin</personne>
<personne num="P6" parents="P2 P4">Camille</personne>

<!-- 
    Entity 
    entity permet de faire référence à une entité, le plus souvent non XML et déclarés dans les fichier DTD
    ce type n'est a utiliser que pour les attributs
-->
<xsd:attribute name="marque" type="xsd:ENTITY" />
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
<telephone marque="samsung">Galaxy SII</telephone>
<telephone marque="apple">Iphone 28</telephone>

<!-- ENTITIES -->
<xsd:attribute name="marque" type="xsd:ENTITIES" />
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
<telephone marque="samsung apple" />

<!-- les éléments et les types complexes-->
<!-- personne élément complexe -->
<personne>
    <!-- élément simple -->
    <nom>Robert</nom>
    <!-- élément simple -->
    <prenom>Axel</prenom>
</personne>

<!-- élément complexe car contient un attribut -->
<personne type="physique">Axel Robert</personne>


<personne attr="test">
    <!-- contient d'autres balises -->
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <!-- la déclaration des attributs de l'élément et les déclarations des autres éléments et attributs à l'intérieur -->
    </xsd:complexType>
</xsd:element>

<!--
    éléments complexes avec du contenu simple
-->
<prix devise="euro">5600</prix>
<voiture marque="Renault" moteur="essence">Clio</voiture>

<!-- élément prix -->
<xsd:element name="prix">
    <!-- indiquer qu'il s'agit d'un élément complexe -->
    <xsd:complexType>
        <!-- préciser que son contenu est simple -->
        <xsd:simpleContent>
            <!-- on déclare le contenu simple de la balise, ici avec une extension pour préciser le type du contenu -->
            <xsd:extension base="xsd:positiveInteger">
                <!-- déclarer l'attribut devise de la balise prix -->
                <xsd:attribute name="devise" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
</xsd:element>

<!-- élément voiture -->
<xsd:element name="voiture">
    <!-- indiquer qu'il s'agit d'un élément complexe -->
    <xsd:complexType>
        <!-- préciser que son contenu est simple -->
        <xsd:simpleContent>
            <!-- on déclare le contenu simple de la balise, ici avec une extension pour préciser le type du contenu -->
            <xsd:extension base="xsd:string">
                <!-- déclarer les attributs marque et moteur de la balise voiture -->
                <xsd:attribute name="marque" type="xsd:string" />
                <xsd:attribute name="moteur" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
</xsd:element>

<!-- balise contenant d'autres balises -->
<personne type="physique">
    <prenom>Axel</prenom>
    <nom>Robert</nom>
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <xsd:sequence>
            <xsd:element name="prenom" type="xsd:string" />
            <xsd:element name="nom" type="xsd:string" />
        </xsd:sequence>
        <xsd:attribute name="type" type="xsd:string" />
    </xsd:complexType>
</xsd:element>

<!-- ATTENTION : sequence implique que l'ordre des balise dans le XML doivent être du même ordre que dans la déclaration -->
<!-- en utilisant all au lieu de sequence, il est possible de déclarer les balises contenues dans n'importe quel ordre -->
<personne type="physique">
    <prenom>Axel</prenom>
    <nom>Robert</nom>
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <xsd:all>
            <xsd:element name="nom" type="xsd:string" />
            <xsd:element name="prenom" type="xsd:string" />
        </xsd:all>
        <xsd:attribute name="type" type="xsd:string" />
    </xsd:complexType>
</xsd:element>
<!-- certaines balises ne sont pas obligatoire, il est possible de les déclarer, dans une liste de choix, utilisée ou non -->

<personne type="physique">
    <prenom>Axel</prenom>
    <nom>Robert</nom>
</personne>
<personne type="morale">
    <nom>GloboCorp Inc.</nom>
</personne>
<personne type="physique">
    <prenom>Jéjé</prenom>
</personne>
<personne type="physique"></personne>

<!-- avec le mot clef choice, il est possible de rendre les balises facultatives-->
<xsd:element name="personne">
    <xsd:complexType>
        <xsd:choice>
            <xsd:element name="nom" type="xsd:string" />
            <xsd:element name="prenom" type="xsd:string" />
        </xsd:choice>
    </xsd:complexType>
    <xsd:attribute name="type" type="xsd:string" />
</xsd:element>

<!-- une type complexe dans un type complexe -->
<personne>
    <identite>
        <nom>Vance</nom>
        <prenom>Jack</prenom>
    </identite>
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <xsd:all>
            <xsd:element name="identite">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="nom" type="xsd:string" />
                        <xsd:element name="prenom" type="xsd:string" />
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
        </xsd:all>
    </xsd:complexType>
</xsd:element>

<!-- contenu mixte -->
<description>
    Une console de <b>80</b>x<b>120</b>cm, <prix>200</prix> euro
</description>

<facture>
    L'acheteur <acheteur>Brendan L. Mulligan</acheteur>, doit payer la somme de <somme>1000</somme> euros
</facture>

<xsd:element name="facture">
    <xsd:complexType mixed="true">
        <xsd:sequence>
            <xsd:element name="acheteur" type="xsd:string" />
            <xsd:element name="somme" type="xsd:float" />
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>

<!-- nb d'occurence : le nombre minimal et maximal d'occurence d'un élément -->
<personne type="personne">
    <nom>Robert</nom>
    <prenom>Axel</prenom>
    <prenom>Maurice</prenom>
    <prenom>Marcel</prenom>
</personne>

<xsd:element name="personne">
    <xsd:complextype>
        <xsd:sequence>
            <xsd:element name="nom" type="xsd:string" />
            <!-- on peut écrire de 1 à 3 prénoms -->
            <xsd:element name="prenom" type="xsd:string" 
                minOccurs="1" 
                maxOccurs="3" />
        </xsd:sequence>
        <xsd:attribute name="type" type="xsd:string" />
    </xsd:complextype>
</xsd:element>

<!-- de 0 à X occurence -->
<personne type="personne">
    <nom>Robert</nom>
    <prenom>Axel</prenom>
    <prenom>Maurice</prenom>
    <prenom>Marcel</prenom>
    <prenom>Jean</prenom>
    <prenom>Michel</prenom>
    <prenom>Oui</prenom>
</personne>
<personne type="personne">
    <nom>Globocorp Inc.</nom>
</personne>

<xsd:element name="personne">
    <xsd:complextype>
        <xsd:sequence>
            <xsd:element name="nom" type="xsd:string" />
            <!-- on peut écrire de 1 à 3 prénoms -->
            <xsd:element name="prenom" type="xsd:string" 
                minOccurs="0" 
                maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="type" type="xsd:string" />
    </xsd:complextype>
</xsd:element>

<!-- 
    réutiliser les types : simplifier l'écriture et la lecture d'un schéma
-->

<banque>
    <!-- 1er client -->
    <client>
        <identite>
            <nom>Adams</nom>
            <prenom>Douglas</prenom>
            <adresse>
                <numero>21</numero>
                <voie>Baker Street</voie>
                <codePostal>W1U 8ED</codePostal>
                <ville>Londre</ville>
                <pays>Angleterre</pays>
            </adresse>
        </identite>
        <!-- liste des comptes bancaires du client -->
        <comptes>
            <compteInteret interets="1.5" nom="Livret A">
                <montant>2500</montant>
            </compteInteret>
            <compte>
                <montant>4200</montant>
            </compte>
        </comptes>
    </client>
</banque>

<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:element name="banque">
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element name="client" maxOccurs="unbounded">
                    <xsd:complexType>
                        <xsd:sequence>
                            <xsd:element name="identite">
                                <xsd:complexType>
                                    <xsd:sequence>
                                        <xsd:element name="nom" type="xsd:string" />
                                        <xsd:element name="prenom" type="xsd:string" />
                                        <xsd:element name="adresse">
                                            <xsd:complexType>
                                                <xsd:sequence>
                                                    <xsd:element name="numero" type="xsd:string" />
                                                    <xsd:element name="voie" type="xsd:string" />
                                                    <xsd:element name="codePostal" type="xsd:string" />
                                                    <xsd:element name="ville" type="xsd:string" />
                                                    <xsd:element name="pays" type="xsd:string" />
                                                </xsd:sequence>
                                            </xsd:complexType>
                                        </xsd:element>
                                    </xsd:sequence>
                                </xsd:complexType>
                            </xsd:element>
                            <xsd:element name="comptes">
                                <xsd:complexType>
                                    <xsd:choice>
                                        <xsd:element name="compteInterets">
                                            <xsd:complexType>
                                                <xsd:sequence>
                                                    <xsd:element name="montant" type="xsd:double" />
                                                </xsd:sequence>
                                                <xsd:attribute name="interets" type="xsd:float" />
                                                <xsd:attribute name="nom" type="xsd:string" />
                                            </xsd:complexType>
                                        </xsd:element>
                                        <xsd:element name="compte">
                                            <xsd:complexType>
                                                <xsd:sequence>
                                                    <xsd:element name="montant" type="xsd:double" />
                                                </xsd:sequence>
                                            </xsd:complexType>
                                        </xsd:element>
                                    </xsd:choice>
                                </xsd:complexType>
                            </xsd:element>
                        </xsd:sequence>
                    </xsd:complexType>
                </xsd:element>
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
</xsd:schema>

<!-- 
    les xsd deviennent très difficiles à lire (et à écrire !), on peut les découper  
    en morceaux réutilisables pour les appliquer et rendre les xsd plus lisibles
    on utilisera le mot-clef ref
-->

<!-- déclaration des éléments en global -->

<xsd:element name="nom" type="xsd:string" />
<xsd:element name="prenom" type="xsd:string" />
<xsd:element name="numero" type="xsd:string" />
<xsd:element name="voie" type="xsd:string" />
<xsd:element name="codePostal" type="xsd:string" />
<xsd:element name="ville" type="xsd:string" />
<xsd:element name="pays" type="xsd:string" />

<!-- groupe des éléments de l'adresse -->

<xsd:group name="grp-adresse">
    <xsd:sequence>
        <xsd:element ref="numero" />
        <xsd:element ref="voie" />
        <xsd:element ref="codePostal" />
        <xsd:element ref="ville" />
        <xsd:element ref="pays" />
    </xsd:sequence>
</xsd:group>

<!-- créer l'élément adresse -->
<xsd:element name="adresse">
    <xsd:complexType>
        <xsd:group ref="grp-adresse" />
    </xsd:complexType>
</xsd:element>

<!-- créer le groupe identité -->

<xsd:group name="grp-identite">
    <xsd:sequence>
        <xsd:element ref="nom" />
        <xsd:element ref="prenom" />
        <xsd:element ref="adresse" />
    </xsd:sequence>
</xsd:group>

<!-- déclaration de l'élément identité -->
<xsd:element name="identite">
    <xsd:complexType>
        <xsd:group ref="grp-identite" />
    </xsd:complexType>
</xsd:element>

<!-- 
on peut créer ses propres types car ici, livret A et compte courant ont le même format 
on déclare donc ses propre types
ex déclaration d'un type simple
____________________________________
<xsd:simpleType name="mon_type_perso">
    <xsd:restriction base="mon_type_perso">
        ...
    </xsd:restriction>
</xsd:simpleType>

utilisation du type simple
____________________________________
<xsd:element name="mon_nom" type="mon_type_perso" />


déclaration type complexe
____________________________________
<xsd:complexType name="mon_type_perso">

</xsd:complexType>

utilisation du type complexe
____________________________________
<xsd:element name="mon_nom" type="mon_type_perso" />
-->

<!-- déclaration d'un type compte général -->

<!-- le montant en global -->
<xsd:element name="montant" type="double" />

<xsd:complexType name="compte">
    <xsd:sequence>
        <xsd:element ref="montant" />
    </xsd:sequence>
</xsd:complexType>

<!-- création du type compte intérets-->

<xsd:complexType name="compteInterets">
    <xsd:complexContent>
        <xsd:extension base="compte">
            <xsd:attribute name="nom" type="xsd:string" />
            <xsd:attribute name="interets" type="xsd:float" />
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

<!-- création de la partie comptes -->
<xsd:element name="comptes">
    <xsd:complexType>
        <xsd:choice>
            <xsd:element name="lep" type="compteInterets" />
            <xsd:element name="bourse" type="compteInterets" />
            <xsd:element name="livretA" type="compteInterets" />
            <xsd:element name="compte" type="compte" />
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>

<!-- création de la partie client -->
<xsd:element name="client">
    <xsd:complexType>
        <xsd:sequence>
            <xsd:element ref="identité" />
            <xsd:element ref="comptes" />
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>

<!-- schema final du xsd -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:element name="banque">
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="client" maxOccurs="unbounded" />
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
</xsd:schema>

<!-- 
    Créer ses propres types (comme compte et compteInteret ) 
    Deux façons de créer ses propres types : 
        - par restriction
        - par Extension (compte et compteInterets)
-->

<!-- Héritage par restriction -->
<!-- 
    type_de_base indique le type de valeur pour la restriction utilisée pour l'héritage
-->
<!-- pour un élément -->
<xsd:element name="mon_nom">
    <xsd:simpleType>
        <xsd:restriction base="type_de_base">
            <!-- détail de la restriction -->
        </xsd:restriction>
    </xsd:simpleType>
</xsd:element>

<!-- pour un attribut -->
<xsd:attribut name="mon_attribut">
    <xsd:simpleType>
        <xsd:restriction base="type_de_base">
            <!-- détail de la restriction -->
        </xsd:restriction>
    </xsd:simpleType>
</xsd:attribut>

<!-- 
    exemple : la balise personne possède un attribut age, dont la valeur doit être entière et  strictement supérieur à 17 et strictement inférieur à 80
-->

<!-- invalide car age < 18-->
<personne age="17" />
<!-- valide car age >= 18-->
<personne age="18" />
<!-- valide car age >= 18-->
<personne age="43" />
<!-- invalide car age >= 80 -->
<personne age="80" />

<xsd:element name="personne">
    <xsd:complexType>
        <!-- on applique le type de la restriction -->
        <xsd:attribute name="age">
            <xsd:simpleType>
                <xsd:restriction base="xsd:nonNegativeInteger">
                    <xsd:minExclusive value="17" />
                    <xsd:maxExclusive value="80" />
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:complexType>
</xsd:element>

<!-- les restrictions s'appliquent de la même manière pour :  
    minExclusive    permet de définir une valeur minimale exclusive
    minInclusive    permet de définir une valeur minimale inclusive
    maxExclusive    permet de définir une valeur maximale exclusive
    maxInclusive    permet de définir une valeur maximale inclusive
    totalDigits     permet de définir le nombre exact de chiffres qui composent un nombre
    fractionDigits  permet de définir le nombre de chiffres autorisés après la virgule
    length          permet de définir le nombre exact de caractères d'une chaîne
    minLength       permet de définir le nombre minimum de caractères d'une chaîne
    maxLength       permet de définir le nombre maximum de caractères d'une chaîne
-->

<!-- enumeration : liste les valeur possible pour un élément (balise ou attribut) -->
<!-- valide -->
<personne type="physique">
    <nom>Duflot</nom>
</personne>
<!-- valide -->
<personne type="morale">
    <nom>Duflot</nom>
</personne>
<!-- invalide -->
<personne type="truc">
    <nom>Duflot</nom>
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <!-- déclaration des balises à l'intérieur de personne-->
        <xsd:element name="nom" />
        <!-- on applique le type de la restriction -->
        <xsd:attribute name="type">
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:enumeration value="physique" />
                    <xsd:enumeration value="morale" />
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:complexType>
</xsd:element>

<!-- 
    whitespace : permet de transformer et gérer les espaces (tabulation, retour à la ligne, espaces simples)  
    dans une balise ou un attribut
    preserve : garde les espaces dans la donnée
    Replace : remplace tous les espaces par des espaces simples (si espace, tab et retour chariot sont présent, remplacés par trois espaces)
    Collapse : remplace tous les espaces par un seul espace simple (si espace, tab et retour chariot sont présent, remplacés par un seul espace)
-->

<nom>Gérad      Manfroi
</nom>

<xsd:element name="nom">
    <xsd:simpleType>
        <xsd:restriction base="xsd:string">
            <xsd:whiteSpace value="collapse" />
        </xsd:restriction>
    </xsd:simpleType>
</xsd:element>

<!-- la donnée dans <nom> sera lue <nom>Gérad Manfroi</nom> -->

<!-- 
    pattern : détermine un motif de données auquel la valeur de la balise ou de l'attribut 
    doit correspondre pour être valide 
-->
<!-- valide -->
<email>
    nduflot@dawan.fr
</email>
<!-- invalide -->
<email>
    nduflot
</email>

<xsd:element name="email">
    <xsd:simpleType>
        <xsd:restriction base="xsd:token">
            <xsd:maxLength value="254" />
            <xsd:pattern value='(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))' />
        </xsd:restriction>
    </xsd:simpleType>
</xsd:element>

<!-- Forcer la première lettre en majuscule et les suivante en minuscules  pattern="^[A-Z][a-z]*$" -->

<!-- Héritage par extension -->
<comptes>
    <courant>
        <montant>2500</montant>
    </courant>
    <interet nom="livretA" interet="1.5">
        <montant>2500</montant>
    </interet>    
</comptes>

<!-- déclaration de l'élément double -->
<xsd:element name="montant" type="double" />

<!-- un type de compte courant -->
<xsd:complexType name="compteCourant">
    <xsd:sequence>
        <xsd:element ref="montant" />
    </xsd:sequence>
</xsd:complexType>

<!-- déclaration de l'élément compte -->
<xsd:element name="courant" type="compteCourant">

<!-- création du type compteInteret, qui est une extension de compte courant -->
<xsd:complexType name="compteInteret">
    <xsd:complexContent>
        <xsd:extension base="compteCourant">
            <xsd:attribute name="nom" type="xsd:string" />
            <xsd:attribute name="interet" type="xsd:float" />
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

<!-- déclaration de la balise interet -->
<xsd:element name="interet" type="compteInteret" />

<xsd:element name="comptes"></xsd:element>
    <xsd:complexType>
        <xsd:choice>
            <xsd:element ref="courant" />
            <xsd:element ref="interet" />
        </xsd:choice>
    </xsd:complexType>
</xsd:element>

<!-- 
    Les identifiants Key et keyRef 
    Permet d'identifier et de référencer les ressources dans un schéma XML en étant plus précis qu'en utilisant
    ID et IDREF
-->
<!-- 
    Key 
    un élément composé d'un selector avec l'attribut xpath
    xpath est le chemin dans l'arbre du xml pour référencer un ou plusieurs autres éléments field (champ)
    qui possèdnet au aussi une expression xpath qui indique l'attribut qui servira d'identifiant
-->

<xsd:key name="nom_identifiant_de_la_clef">
    <xsd:selector xpath="expression xpath" />
    <!-- les champs concernés par la clef -->
    <xsd:field xpath="expression xpath" />
</xsd:key>

<!-- avec le xml suivant -->
<famille>
    <parent id="per-1" />
    <enfant id="per-2" parent="per-1" />
</famille>

<!-- 
    la famille possède deux éléments, un parent, un enfant.
    Chacun possède un attribut unique id, 
    l'enfant possède en plus un attribut parent contenant l'id de son parent
-->

<!-- xsd sans les identifiants -->
<!-- parent -->
<xsd:element name="parent">
    <xsd:complexType>
        <xsd:attribute name="id" type="xsd:NCName" />
    </xsd:complexType>
</xsd:element>
<!-- enfant -->
<xsd:element name="parent">
    <xsd:complexType>
        <xsd:attribute name="id" type="xsd:NCName" />
        <xsd:attribute name="parent" type="xsd:NCName" />
    </xsd:complexType>
</xsd:element>
<!-- famille -->
<xsd:element name="famille">
    <xsd:complexType>
        <xsd:choice>
            <xsd:element ref="parent" />
            <xsd:element ref="enfant" />
        </xsd:choice>
    </xsd:complexType>
</xsd:element>

<!-- en utilisant key et keyref -->
<!-- identifiant (key, la clef) du parent -->
<!-- je déclare une clef pour la balise parent qui s'appelle parentId-->
<xsd:key name="parentId">
    <!-- je donne la localisation de la balise parent en chemin absolu (depuis la racine du xml) -->
    <xsd:selector xpath="/parent" />
    <!-- d'indique, dans cette balise, quel champ (ici un attribut) correspond à la clef -->
    <xsd:field xpath="@id" />
</xsd:key>
<!-- identifiant (key, la clef) de l'enfant -->
<xsd:key name="enfantId">
    <!-- je donne la localisation de la balise enfant en chemin absolu (depuis la racine du xml) -->
    <xsd:selector xpath="/enfant" />
    <!-- d'indique, dans cette balise, quel champ (ici un attribut) correspond à la clef -->
    <xsd:field xpath="@id" />
</xsd:key>
<!-- faire le lien entre l'attribut id (@id) d'un parent et l'attribut parent d'un enfant -->
<!-- on déclare une référence de clef, sur la clef parentId, cette référence est nommée parentIdRef -->
<xsd:keyref name="parentIdRef" refer="parentId">
    <!-- on cible la balise qui aura cette référence, ici la balise enfant -->
    <xsd:selector xpath="/enfant" />
    <!-- on indique quel attribut (field) de la balise enfant fait la référence à la clef parentId, ici le champ parent -->
    <xsd:field xpath="@parent" />
</xsd:keyref>