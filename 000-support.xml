<!--
    L'espace de nom donne un contexte à un terme, par exemple certains mots ont plusieurs définitions, 
    c'est le contexte dans lequel on utilise ce mot qui donne sa "fonction / définition" finale

    On peut par exemple associer le document à l’espace de nom XHTML et par soucis de praticité 
    on va utiliser le préfixe html (faciliter la lecture humaine du document) 
    car il faut savoir qu’à la base le choix du préfixe est totalement arbitraire.
-->
<html:html xmlns:html="http://www.w3.org/1999/xhtml">
    <html:head>
        <html:title>Les espaces de noms</html:title>
    </html:head>
    <html:body>
        ....
    </html:body>
</html:html>

<!--
    il est possible de déclarer plusieurs espaces de nom pour un même document
-->
<html:html 
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:mml="http://www.w3.org/1998/Math/MathML"
    >
    <html:head>
        <html:title>Les espaces de noms</html:title>
    </html:head>
    <html:body>
        ....
        <mml:math>
            <mml:apply>
                <mml:eq>
                    ...
                </mml:eq>
            </mml:apply>
        </mml:math>
    </html:body>
</html:html>

<!-- 
    on peut limiter la portée de la déclaration d'un espace de nom,
    pour la déclaration multiple, il est aussi possible de n'utiliser (d'appeler) une espace de nom 
    seulement quand il est requis
-->
<!-- Ici on utlise le dialecte html -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        ....
        <!-- à partir de cette balise, on utilise le dialect math et plus le dialecte html -->
        <math xmlns="http://www.w3.org/1998/Math/MathML"> 
            <apply>
                <eq>
                    ...
                </eq>
            </apply>
        </math>
        <!-- on est "sorti" de la portée du dialecte math, on reviens dansle dialecte html -->
    </body>
</html>

<!--
    Mais comment faisons nous s'il n'existe pas de contexte pour nos données, ou seulement une partie ?
    Il est possible "d'annuler" un espace de nom (de la même façon que l'on a appelé un espace de nom de manière ponctuelle)
-->

<!-- Ici on utlise le dialecte html -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        ....
        <!-- 
            En déclarant xmlns à 'vide' pour la balise name, elle-même et les balises qu'elle contient ne se réfèreront plus au
            vocabulaire xhtml
        -->
        <name xmlns=""> 
            <firstName>Gaston</firstName>
            <lastName>Lagaffe</lastName>
        </name>
        <!-- à la sortie de la balise name, on revient dans le dialect xhtml -->
    </body>
</html>

<!-- 
XML
    http://www.w3.org/XML/1998/namespace 
XInclude
    http://www.w3.org/2001/XInclude 
XLink
    http://www.w3.org/1999/xlink 
MathML
    http://www.w3.org/1998/Math/MathML 
XHTML
    http://www.w3.org/1999/xhtml 
SVG
    http://www.w3.org/2000/svg 
Schémas
    http://www.w3.org/2001/XMLSchema 
Instances de schémas
    http://www.w3.org/2001/XMLSchema-instance 
Schematron
    http://purl.oclc.org/dsdl/schematron 
XSLT
    http://www.w3.org/1999/XSL/Transform 
XSL-FO
    http://www.w3.org/1999/XSL/Format 
DocBook
    https://tdg.docbook.org/tdg/5.1/ 
Dublin Core
    https://www.dublincore.org/specifications/dublin-core/dcmi-terms/ 


-->

<!-- DTD -->


<!ELEMENT balise (contenu)>

<!-- Balise contenant une autre balise -->
<contact>
    <nom>Durant</nom>
</contact>
<!-- pour la balise contact -->
<!ELEMENT contact (nom)>
<!-- pour la balise nom -->
<!ELEMENT nom (#PCDATA)>
<!-- Si la balise nom est vide -->
<!ELEMENT nom EMPTY>
<!-- une balise vide avec un attribut -->
<!-- Les attributs -->
<!ELEMENT balise (contenu)>
    <!ATTLIST balise attr>

<console src="test" />
<!ELEMENT console EMPTY>
    <!ATTLIST console src CDATA>

<!-- si la balise peut ou non avoir des données -->
<!ELEMENT nom ANY>
<!-- si la balise peut contenir plusieurs itérations d'une même balise -->
<!ELEMENT rolodex (contact+)>

<!-- avec le xml suivant -->
<rolodex>
    <contact>
        <nom>Durand</nom>
        <prenom>Jean</prenom>
        <age>42</age>
    </contact>
    <contact>
        <nom>ACME Inc</nom>
        <prenom></prenom>
        <age></age>
    </contact>
</rolodex>

<!ELEMENT rolodex (contact+)>
    <!ELEMENT contact (nom, prenom, age)>
        <!ELEMENT nom (#PCDATA)>
        <!ELEMENT prenom (#PCDATA)>
        <!ELEMENT age (#PCDATA)>
<!-- on peut avoir plusieurs contenus possible dans une balise -->

<!ELEMENT rolodex (contact+)>
    <!ELEMENT contact (nom | prenom, age)>
    <!-- ici, contact doit contenir soit un nom ou soit un prenom et age -->
    <!ELEMENT nom (#PCDATA)>
    <!ELEMENT prenom (#PCDATA)>
    <!ELEMENT age (#PCDATA)>
    
<!-- balise optionnelles : qu'elle apparaissent ou non -->
<!ELEMENT contact (nom, prenom?, adresses, emails)>
<!-- ici, la balise prénom peut ne pas apparaître -->

<!-- balise optionnelles répétées -->
<!ELEMENT adresses (adresse*)>
<!-- ici, la balise adresses peut contenir de 0 à X adresse -->

<!-- balise obligatoires répétées -->
<!ELEMENT rolodex (contact+)>
<!-- ici, rolodex doit contenir au moins une balise contact et peut en contenir plus -->

<!-- Les attributs -->
<!ELEMENT balise (contenu)>
    <!ATTLIST balise attr >

<!-- identifiant unique -->
<contact numero="n-1"></contact>
<!ELEMENT contact ANY>
    <!ATTLIST contact numero ID #REQUIRED>
<!-- la balise contact possède un attribut numéro qui est une attribut ID qui est unique et obligatoire -->

<!-- 
    Propriété de présence des attributs
    forme               signification
    #IMPLIED            Attribut facultatif
    #REQUIRED           Attribut obligatoire
    #FIXED valeur       Attribut avec cette valeur, non modifiable
    "valeur"            Attribut avec cette valeur par défaut et modifiable
-->

<!-- Attribut ayant pour référence (qui fait référence à) un attribut a valeur unique -->
<!ELEMENT contact ANY>
    <!ATTLIST contact numero ID #REQUIRED>
<!ELEMENT adresse ANY>
    <!ATTLIST adresse userAdresse IDREF #REQUIRED>
    <!ATTLIST adresse personne (physique | morale) "physique">
<rolodex>
    <contacts>
        <contact personne="physique" numero="n-1">
            ....
        </contact>
        <contact personne="morale" numero="n-2">
            ....
        </contact>
    </contacts>
    <adresses>
        <adresse type="facturation" userAdresse="n-1">
            ....
        </adresse>
        <adresse type="livraison" userAdresse="n-1">
            ....
        </adresse>
        <adresse type="facturation" userAdresse="n-2">
            ....
        </adresse>
    </adresses>
</rolodex>

<!-- autre exemple -->
<artist name="Nick Cave" artistID="NC"/>
<album name="Murder Ballads" albumArtistID="NC"/>
<album name="The boatman's call" albumArtistID="NC"/>

<!ELEMENT artist EMPTY>
<!ATTLIST artist name CDATA #REQUIRED>
<!ATTLIST artist artistID ID #REQUIRED>

<!ELEMENT album EMPTY>
<!ATTLIST album name CDATA #REQUIRED>
<!ATTLIST album albumArtistID IDREF #IMPLIED>


<!-- exemple IDREFS (plusieurs élément référence le même élément -->
<artist name="Korn" artistID="K-0001" />
<artist name="Ice Cube" artistID="IC-0002" />
<artist name="Incubus" artistID="I-0003" />
<artist name="Limp Bizkit" artistID="LB-0004" />
<artist name="Orgy" artistID="O-0005" />
<album name="Follow the leader" albumArtistID="K-0001" />
<album name="Family values tour '98" albumArtistID="K-0001 IC-0002 I-0003 LB-0004 O-0005" />

<!ELEMENT artist EMPTY>
<!ATTLIST artist name CDATA #REQUIRED>
<!ATTLIST artist artistID ID #REQUIRED>

<!ELEMENT album EMPTY>
<!ATTLIST album name CDATA #REQUIRED>
<!ATTLIST album albumArtistID IDREFS #IMPLIED>

<!-- attribut avec une valeur par dfaut -->
<!ATTLIST adresse personne (physique | morale) "physique">
<!-- valide -->
<contact personne="physique"></contact>

<!-- valide -->
<contact personne="morale"></contact>

<!-- invalide -->
<contact personne="toto"></contact>

<!-- valide mais sera considéré par défaut comme physique -->
<contact personne=""></contact>

<!-- 
    les constantes : si l'attribut est présent dans la balise, il doit avoir une valeur définie. 
    Mais s'il n'est pas présent, cette valeur sera celle utilisée par défaut
-->
<!ATTLIST prix devise CDATA "euro">
<!-- valide la devise sera euro et rien d'autre -->
<prix devise="euro">12</prix>
<!-- valide la devise sera euro et rien d'autre -->
<prix>12</prix>

<!-- invalide : la devise doit être en euro -->
<prix devise="USD">12</prix>

<!-- 
    Les entités 
    se sont des alias qui permettent de réutiliser des informations dans le document xml ou dans les DTD
        - générales
        - paramètres
        - externes
-->

<!-- 
    entité générale
    associe un alias à une information dans le document
-->

<!ENTITY dacia "Dacia">
<!ENTITY renault "Renault">
<!ENTITY citroen "Citroën">

<voiture>
    <marque>&dacia;</marque>
</voiture>
<voiture>
    <marque>&renault;</marque>
</voiture>
<voiture>
    <marque>&citroen;</marque>
</voiture>

<!-- 
    le xml est à lire comme suit
-->

<voiture>
    <marque>Dacia</marque>
</voiture>
<voiture>
    <marque>Renault</marque>
</voiture>
<voiture>
    <marque>Citroën</marque>
</voiture>

<!-- 
    entité paramètre
    N'apparaît que dans les DTD
    Elle associent un alias à une partie de la déclaration dans les DTD
-->

<voiture marque="Dacia" />
<voiture marque="Renault" />
<voiture marque="Citroën" />
<!-- DTD classique pour l'attribut marque -->
<!ATTLIST voiture marque (Dacia|Renault|Citroën) #REQUIRED>

<!-- avec l'entité paramètre -->
<!ENTITY % listeMarques "marque (Dacia|Renault|Citroën) #REQUIRED">
<!ATTLIST voiture %listeMarques>

<!-- autre exemple -->
<!ENTITY % type "nom?, prenom?">
<!ELEMENT contact (%type, surnom?)>
<!ELEMENT personnage (%type, role)>

<!-- traduit en DTD classique -->
<!ELEMENT contact (nom?, prenom?, surnom?)>
<!ELEME?T personnage (nom?, prenom?, role)>

<!-- 
    Entité externe 
    Permetttent de faire référence, comme les entités générales, à des informations a utiliser dans le document 
    xml, mais elle sont écrites et déclarées dans un fichier externe
-->

<!ENTITY dacia SYSTEM "dacia.xml">
<!ENTITY renault SYSTEM "renault.xml">
<!ENTITY citroen SYSTEM "citroen.xml">
<voiture>
    &dacia;
</voiture>
<voiture>
    &renault;
</voiture>
<voiture>
    &citroen;
</voiture>


<!-- dacia.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE description [
    <!ELEMENT description (marque, modele, portes)>
    <!ELEMENT marque (#PCDATA)>
    <!ELEMENT modele (#PCDATA)>
    <!ELEMENT portes (#PCDATA)>
]>
<description>
    <marque>
        Dacia
    </marque>
    <modele>
        Sandero
    </modele>
    <portes>
        5
    </portes>
</description>

<!-- 
    Autre schéma de validation XML : XSD (Xml Schema Definition)
    Pourquoi ? 
    les DTD ne sont pas au format XML, c'est un nouveau langage avec sa propre syntaxe et ses règles.
    => il faut l'utiliser avec xml et il se peut que certaines API liront le XML et les DTD de façons différentes?
    Enfin, on ne peut pas typer les données, on indique juste qu'une balise contient ou non des données 
    mais impossible de préciser si c'est une chaîne de caractère, un nombre, etc.
    
    Le xsd permet de typer les données, il est plus précis sur l'écriture des contraintes, il s'écrit en xml, 
    se stocke dans un fichier externe ayant l'extension .xsd, il utilise comme les fichiers xml un prologue 
    dont le nom de l'élément racine nous est imposé
-->

<!-- prologue d'un fichier .xsd -->
<?xml version="1.0" encoding="UTF-8"?>
<!-- élément racine -->
<xsd:schema xmlns="http://www.w3.org/2001/XMLSchema">
</xsd:schema>

<!-- on déclare un espace de nom avec xmlns:xsd, de fait, tous les éléments du xsd seront préfixés par xsd: -->

<!-- 
    il faut ensuite rattacher ce fichier de schéma au xml concerné par le xsd
    il faut déclarer l'attachement du fichier dans la balise racine du xml
    mais pour appeler ce fichier il faut utiliser le vocabulaire schema-instance
-->

<!-- xsd ne décrivant pas d'espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="agenda.xsd">
    <!-- schemaLocation déclare un xsd ne décrivant pas un espace de nom -->
    <rolodex>
        <nom>
            Durant
        </nom>
    </rolodex>
    <garage>
        <voiture>
            <marque>
                Opel
            </marque>
        </voiture>
    </garage>
</agenda>

<!-- xsd déclarant un espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:Contact contact.xsd" xsi:schemaLocation="urn:Garage garage.xsd">
    <!-- schemaLocation déclare un xsd décrivant un espace de nom -->
    <Contact:contact xmlns:Contact="urn:Contact">
        <Contact:nom>
            Durant
        </Contact:nom>
    </Contact:contact>
    <Garage:garage xmlns:Garage="urn:Garage">
        <Garage:voiture>
            <Garage:marque>
                Opel
            </Garage:marque>
        </Garage:voiture>
    </Garage:garage>
</agenda>

<!-- 
    Déclaration des éléments
    Deux type d'éléments : simples et complexes

    Élément simple : 
    une balise, sans attribut, ne contenant pas d'autre balise, dont le type de donnée contenu est simple
    
    Élément comlexe : 
    une balise qui contient d'autre balise, ou que le type de donnée est complexe, ou qu'elle contient au moins un attribut.
-->

<!-- ni atribut, ni élément et donnée simple => élément simple -->
<nom>Duflot</nom>

<!-- Contient un attribut : personne est un élément complexe -->
<!-- attribut type : contient une donnée simple => élément simple -->
<personne type="physique">Nicolas Duflot</personne>

<!-- Élement comple (contient d'autres balise -->
<personne>
    <!-- Élément complexe (contient un attribut) -->
    <nom type="usage">Duflot</nom>
    <nom type="jeune-fille">Duflot</nom>
    <!-- Élement simple (ni attribut ni balise) -->
    <prenom>Tiphaine</prenom>
</personne>

<!-- 
    déclarer  un élément simple
    mot clef : element (avec le namespace déterminé, pour l'exemple xsd)
-->

<nom>Duflot</nom>
<prenom>Nicolas</prenom>
<age>43</age>

<!-- en xsd -->
<xsd:element name="nom" type="xsd:string" />
<xsd:element name="prenom" type="xsd:string" />
<xsd:element name="age" type="xsd:int" />

<!-- valeurs par défaut -->
<xsd:element name="nom" type="xsd:string" default="Doe" />
<xsd:element name="prenom" type="xsd:string" default="John" />
<xsd:element name="age" type="xsd:int" />

<!-- exemple de xml valides avec ce schéma -->
<!-- ex n°1 -->
<nom>Duflot</nom>
<prenom>Nicolas</prenom>
<age>43</age>

<!-- ex n°1 -->
<nom></nom>         <!-- valeur par défaut "Doe"-->
<prenom>Nicolas</prenom>
<age>43</age>

<!-- ex n°2 -->
<nom>Duflot</nom>
<prenom></prenom>   <!-- valeur par défaut "John"-->
<age>43</age>

<!-- ex n°3 -->
<nom></nom>         <!-- valeur par défaut "Doe"-->
<prenom></prenom>   <!-- valeur par défaut "John"-->
<age>43</age>

<!-- ex n°4 -->
<nom></nom>         <!-- valeur par défaut "Doe"-->
<prenom></prenom>   <!-- valeur par défaut "John"-->
<age></age>         <!-- il n'y a pas de valeur par défaut, mais peut être vide car non obligatoire -->

<!-- 
    Valeurs constantes
    Constante : valeur inchangeable, imposée et non valide si la balise est vide
-->

<xsd:element name="status" type="xsd:string" fixed="Employé·e" />
<!-- valide -->
<status>Employé·e</status>
<!-- invalide car donnée <> Employé·e -->
<status>Junior</status>
<!-- invalide car donnée absente -->
<status></status>

<!-- 
    Les attributs

    Se sont par essence des éléments simples, et le mot clef pour les déclarer 
    n'est pas element mais attribute (ne pas oublier le namespace xsd)

    on déclare un attribut avec les attributs name et type
-->

<personne type="physique"></personne>

<!-- attribut personne -->
<xsd:attribute name="type" type="xsd:string" />
<!-- 
    la déclaration de cet attribut intervient évidement lors de la déclaration 
    de l'élément personne, qui lui est un élément complexe, on verra sa déclaration plus tard 
-->

<!-- valeurs par défaut, valeurs inchangeables (constante), valeurs obligatoires -->
<!-- par défaut -->
<xsd:attribute name="type" type="xsd:string" default="physique" />
<!-- constante -->
<xsd:attribute name="devise" type="xsd:string" fixed="euro" />
<!-- valide -->
<prix devise="euro">23.5</prix>
<!-- valide -->
<prix devise="">23.5</prix>

<!-- l'attribut type doit être obligatoirement renseigné dans la balise personne -->
<xsd:attribute name="type" type="xsd:string" use="required" />
<!-- valide -->
<personne type="physique"></personne>
<!-- invalide -->
<personne type=""></personne>
<!-- invalide -->
<personne></personne>

<!-- les types de valeurs pour les élément et les attributs -->
<!-- string -->
<xsd:element name="string" type="xsd:string" />
<string>Karamasov</string>
<string>Une phrase choc</string>
<!-- certains caractères spéciaux, tel &, doivent être écrits avec la notation HTML & => &amp; -->
<string>&amp;</string>

<!-- language -->
<xsd:element name="langue" type="xsd:language" />
<!-- 
    norme code langue 
    deux lettres de base ISO 639 (code de la langue)
    peut être suivi par deux lettres ISO 3166 (code du pays)
    XX      (seul le code langue)
    XX-YY   (code langue-code pays)
-->
<langue>fr-FR</langue>
<langue>fr-CA</langue>
<langue>en</langue>
<langue>en-US</langue>
<langue>en-GB</langue>
<langue>en-CA</langue>

<!--
    nmtoken string sans espace et seulement avec les caractère spéciaux acceptés .-_ et : 
    ne peut être utilisé que pour un attribut
-->
<xsd:attribute name="myToken" type="xsd:NMTOKEN" />
<balise myToken="A:B_B-2.3">Contenu de la balise</balise>

<!--
    nmtokens : liste de nttoken, séparés par un espace, mais seulement avec les caractère spéciaux acceptés .-_ et : 
    ne peut être utilisé que pour un attribut
-->
<xsd:attribute name="myTokens" type="xsd:NMTOKENS" />
<balise myTokens="A:B_B-2.3">Contenu de la balise</balise>
<balise myTokens="A:B_B-2.3 AZERTY 123456">Contenu de la balise</balise>

<!-- ID IDREF -->
<xsd:attribute name="num" type="ID" />
<xsd:attribute name="parent" type="IDREF" />
<personne num="P1">Paul</personne>
<personne num="P2">JP</personne>
<personne num="P3" parent="P1">Martin</personne>
<personne num="P4" parent="P2">Camille</personne>

<!-- ID IDREFS -->
<xsd:attribute name="num" type="ID" />
<xsd:attribute name="parents" type="IDREFS" />
<personne num="P0" parents="">Clotaire</personne>
<personne num="P1" parents="">JP</personne>
<personne num="P2" parents="">Marie</personne>
<personne num="P3" parents="P0">Astrid</personne>
<personne num="P4" parentss="P0">Paul</personne>
<personne num="P5" parents="P1 P3">Martin</personne>
<personne num="P6" parents="P2 P4">Camille</personne>

<!-- 
    Entity 
    entity permet de faire référence à une entité, le plus souvent non XML et déclarés dans les fichier DTD
    ce type n'est a utiliser que pour les attributs
-->
<xsd:attribute name="marque" type="xsd:ENTITY" />
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
<telephone marque="samsung">Galaxy SII</telephone>
<telephone marque="apple">Iphone 28</telephone>

<!-- ENTITIES -->
<xsd:attribute name="marque" type="xsd:ENTITIES" />
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
<telephone marque="samsung apple" />

<!-- les éléments et les types complexes-->
<!-- personne élément complexe -->
<personne>
    <!-- élément simple -->
    <nom>Robert</nom>
    <!-- élément simple -->
    <prenom>Axel</prenom>
</personne>

<!-- élément complexe car contient un attribut -->
<personne type="physique">Axel Robert</personne>


<personne attr="test">
    <!-- contient d'autres balises -->
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <!-- la déclaration des attributs de l'élément et les déclarations des autres éléments et attributs à l'intérieur -->
    </xsd:complexType>
</xsd:element>

<!--
    éléments complexes avec du contenu simple
-->
<prix devise="euro">5600</prix>
<voiture marque="Renault" moteur="essence">Clio</voiture>

<!-- élément prix -->
<xsd:element name="prix">
    <!-- indiquer qu'il s'agit d'un élément complexe -->
    <xsd:complexType>
        <!-- préciser que son contenu est simple -->
        <xsd:simpleContent>
            <!-- on déclare le contenu simple de la balise, ici avec une extension pour préciser le type du contenu -->
            <xsd:extension base="xsd:positiveInteger">
                <!-- déclarer l'attribut devise de la balise prix -->
                <xsd:attribute name="devise" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
</xsd:element>

<!-- élément voiture -->
<xsd:element name="voiture">
    <!-- indiquer qu'il s'agit d'un élément complexe -->
    <xsd:complexType>
        <!-- préciser que son contenu est simple -->
        <xsd:simpleContent>
            <!-- on déclare le contenu simple de la balise, ici avec une extension pour préciser le type du contenu -->
            <xsd:extension base="xsd:string">
                <!-- déclarer les attributs marque et moteur de la balise voiture -->
                <xsd:attribute name="devise" type="xsd:string" />
                <xsd:attribute name="devise" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
</xsd:element>